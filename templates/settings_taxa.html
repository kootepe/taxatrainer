<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Taxa Asetukset</title>
  <link rel="stylesheet" href="/static/style.css" />
</head>
<body>
  <main class="wrap">
    <header class="top">
      <h1>Taxa Asetukset</h1>
      <div style="display:flex; gap:10px;">
        <a class="btn secondary" href="/settings">Taso asetukset</a>
        <a class="btn" href="/">Takaisin</a>
      </div>
    </header>

    <section class="card">
      {% if saved %}
        <div style="margin-bottom: 12px; opacity: 0.95;">✅ Saved</div>
      {% endif %}

      <p style="margin-top:0; opacity:0.9;">
      Merkkaa taksonit joita haluat harjoitella.
      </p>

      <form method="POST" action="/settings/taxa">
      <button style="margin-bottom:15px;" class="btn" type="submit">Tallenna</button>
        {% macro render_node(n, depth=0) -%}
          <div style="margin-left: {{ depth * 18 }}px; padding: 6px 0;">
            <label style="display:flex; gap:10px; align-items:center;">
              <input
                type="checkbox"
                name="enabled"
                value="{{ n.id }}"
                data-id="{{ n.id }}"
                {% if n.id in enabled %}checked{% endif %}
              />
              <span style="text-transform: capitalize; opacity:0.9;">{{ n.rank }}</span>
              <span>—</span>
              <span>{{ n.lat }}</span>
              <span>—</span>
              <span>{{ n.fin }}</span>
            </label>
          </div>
          {% for ch in n.children %}
            {{ render_node(ch, depth + 1) }}
          {% endfor %}
        {%- endmacro %}

        <div style="margin: 10px 0 16px 0;">
          {% for n in tree %}
            {{ render_node(n, 0) }}
          {% endfor %}
        </div>

      </form>
    </section>
  </main>

<script>
  function getAllBoxes() {
    return Array.from(document.querySelectorAll('input[type="checkbox"][name="enabled"][data-id]'));
  }

  function isDescendant(childId, parentId) {
    return childId === parentId || childId.startsWith(parentId + ">");
  }

  function setDescendants(parentId, checked) {
    for (const cb of getAllBoxes()) {
      const id = cb.dataset.id;
      if (isDescendant(id, parentId)) {
        cb.checked = checked;
      }
    }
  }

  function getParentId(id) {
    const i = id.lastIndexOf(">");
    return i >= 0 ? id.slice(0, i) : null;
  }

  function updateParentsFromChildren(startId) {
    // Walk upwards, updating each parent based on its direct children.
    let pid = getParentId(startId);
    const boxes = getAllBoxes();
    const byId = new Map(boxes.map(b => [b.dataset.id, b]));

    while (pid) {
      const parentBox = byId.get(pid);
      if (!parentBox) {
        pid = getParentId(pid);
        continue;
      }

      // direct children = those with exactly one more segment
      const parentDepth = pid.split(">").length;
      const directKids = boxes.filter(b => {
        const id = b.dataset.id;
        return id.startsWith(pid + ">") && id.split(">").length === parentDepth + 1;
      });

      if (directKids.length === 0) {
        pid = getParentId(pid);
        continue;
      }

      const allChecked = directKids.every(b => b.checked);
      const anyChecked = directKids.some(b => b.checked);

      // If you want tri-state visuals, you can use indeterminate:
      parentBox.indeterminate = anyChecked && !allChecked;
      parentBox.checked = allChecked;

      pid = getParentId(pid);
    }
  }

  // Bind listeners
  for (const cb of getAllBoxes()) {
    cb.addEventListener("change", (e) => {
      const id = cb.dataset.id;
      const checked = cb.checked;

      // 1) toggle all descendants
      setDescendants(id, checked);

      // 2) update all ancestors (optional but nice)
      // pick one descendant id to seed the update; current id is fine
      updateParentsFromChildren(id);
    });
  }

  // On load: compute indeterminate/parent state from initially checked items
  // (use deepest-first so parents compute correctly)
  const boxes = getAllBoxes().sort((a,b) => b.dataset.id.length - a.dataset.id.length);
  for (const cb of boxes) {
    updateParentsFromChildren(cb.dataset.id);
  }
</script>
</body>
</html>

