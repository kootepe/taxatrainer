<!doctype html>
<html lang="en">
<head>
  <link rel="preload" href="{{ url_for('static', filename='style.css') }}" as="style">
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Taxa treenaus</title>
</head>
<body data-actions="{{actions_position }}">
  <main class="wrap">
    <header class="top">
      <h1>Taxatreeni</h1>
      <div style="display:flex; gap:10px;">
        <a class="btn secondary" href="/manual">Ohjeet</a>
        <a class="btn secondary" href="/settings">Asetukset</a>
      </div>
    </header>

      <div class="actions">
        <button id="showBtn" class="btn secondary" type="button">Näytä</button>
        <button id="newBtn" class="btn">Uusi</button>
      </div>
    <section class="card">

      <div id="clickhint" style="margin-bottom:15px;">
        <span>Ekalla klikkauksella lattarit näkyviin, toisella suomenkieliset</span>
      </div>


      <div class="cardHeader">
        <strong class="cardTitle">
          <span id="fin">{{ item.meta.fin }}</span>
        </strong>

        <div id="cardCounter" class="cardCounter">
          {{ counter }} / {{ total }}
        </div>
      </div>
      <!-- <div class="hint"> -->
      <!--   <div> <strong><span id="fin">{{ item.meta.fin }}</span></strong></div> -->
      <!-- </div> -->



      <form id="form" autocomplete="off">
        {% for r in ranks %}

          <label class="row" id="row_{{ r }}">
            <span class="rank">
              {{ rank_fi.get(r, "") }}
            </span>

            <div class="cell">
              <span class="staticVal" id="in_{{ r }}">Klikkaa näkyviin</span>
            </div>

            <div class="result" id="res_{{ r }}" hidden></div>
          </label>
        {% endfor %}
      </form>


      <pre id="answers" class="answers" style="display:none;"></pre>
    </section>

<div id="imgBox" class="imgBox" style="display:none;">
  <div id="thumbs" class="thumbs"></div>
</div>

<div id="lightbox" class="lightbox" hidden>
  <div class="lightboxInner">
    <img id="lightboxImg" alt="large preview" />
    <div id="lightboxCaption" class="lightboxCaption"></div>
    <div id="lightboxLink" class="lightboxLink">
          </div>
  </div>
</div>
  </main>

  <script>
    const RANK_FI = {{ rank_fi|tojson }};

    let current = {
      answer: {{ item.answer|tojson }},
      meta: {{ item.meta|tojson }},
      quiz_ranks: {{ ranks|tojson }},     // ranks rendered for THIS card
      mode: {{ quiz_mode|tojson }},
      given: {{ given|tojson }},
      counter: {{ counter|tojson }},
      total: {{ total|tojson }},
      hint_language: {{ hint_language|tojson }},
      img_toggle: {{ img_toggle|tojson }},
    };

    let showMode = "hidden"; // hidden -> lat -> fin -> lat -> fin ...
    let rankShowMode = Object.create(null); // per-row ( ? )
    function getRanks() {
      return current.quiz_ranks || [];
    }

    updateCounter();
    function norm(s) {
      return (s ?? "").toString().trim().toLowerCase().replace(/\s+/g, " ");
    }


function updateCounter() {
  const el = document.getElementById("cardCounter");
  if (!el) return;

  const c = current?.counter ?? "";
  const t = current?.total ?? "";
  el.textContent = `${c} / ${t}`.trim();
}


function getFinForRank(rank) {
  const byRank = current?.meta?.fin_by_rank?.[rank];
  if (byRank && String(byRank).trim()) return String(byRank).trim();

  const one = current?.meta?.fin;
  if (one && String(one).trim()) return String(one).trim();

  return "";
}
function formatByMode(rank, mode) {
  const lat = (current.answer?.[rank] ?? "").toString().trim();
  if (!lat) return "";

  if (mode === "fin") {
    const fin = getFinForRank(rank);
    return fin || lat;
  }
  return lat; // "lat" or default
}
function formatShown(rank) {
  const lat = (current.answer?.[rank] ?? "").toString().trim();
  if (!lat) return "";

  if (showMode === "fin") {
    const fin = getFinForRank(rank);
    return fin || lat; // fallback to latin if no finnish
  }

  // default latin
  return lat;
}
function applyVisibleFieldsFromAnswer(answer) {
  for (const r of getRanks() ) {
    const row = document.getElementById("row_" + r);
    const input = document.getElementById("in_" + r);

    // If ids don't match, don't crash silently
    if (!row || !input) {
      console.warn("Missing DOM for rank:", r, { row, input });
      continue;
    }

    const raw = answer?.[r];
    const expected = (raw === null || raw === undefined) ? "" : String(raw);
    const shouldShow = expected.trim().length > 0;

    row.hidden = !shouldShow; //

    if (!shouldShow) {
      input.value = "";
      input.classList.remove("ok", "bad");
    }
  }
}

function openLightbox(photo) {
  const lb = document.getElementById("lightbox");
  const im = document.getElementById("lightboxImg");
  const cap = document.getElementById("lightboxCaption");
  const linkel = document.getElementById("lightboxLink");
  if (!lb || !im) return;

  const link = document.createElement("a");
  link.href = photo.photo_page_url;
  link.textContent = "Link to original";
  link.target = "_blank"; // optional

  linkel.appendChild(link)

  im.src = photo.url || photo.url_square || "";
  lb.hidden = false;

  const txt = (photo.attribution || "").trim();
  cap.textContent = txt ? txt : "";
}

function closeLightbox() {
  const lb = document.getElementById("lightbox");
  const im = document.getElementById("lightboxImg");
  const cap = document.getElementById("lightboxCaption");
  const ln = document.getElementById("lightboxLink");
  if (!lb || !im) return;
  lb.hidden = true;
  im.removeAttribute("src");
  ln.innerHTML = '';
  if (cap) cap.textContent = "";
}

function setImage(meta) {
  const imgBox = document.getElementById("imgBox");
  const thumbs = document.getElementById("thumbs");
  if (!imgBox || !thumbs) return;

  if (!current?.img_toggle) {
    if (imgBox) imgBox.style.display = "none";
    return;
      }

  const photos = meta?.images || [];
  if (!Array.isArray(photos) || photos.length === 0) {
    thumbs.innerHTML = "";
    imgBox.style.display = "none";
    return;
  }

  imgBox.style.display = "block";
  thumbs.innerHTML = photos.map((p, i) => {
    const src = (p.url_square || p.url || "").toString();
    return `
      <div class="thumb" data-i="${i}" title="Klikkaa suuremmaksi">
        <img src="${src}" alt="photo ${i+1}" loading="lazy" />
      </div>
    `;
  }).join("");

  // bind clicks
  thumbs.querySelectorAll(".thumb").forEach(el => {
    el.addEventListener("click", () => {
      const i = Number(el.dataset.i || "0");
      openLightbox(photos[i]);
    });
  });
}


function updateMeta(meta) {
  setImage(meta);
  renderGivenBox(); // updates fin + given text together
}

function clearInputs() {
  for (const r of getRanks()) {
    const el = document.getElementById("in_" + r);
    el.textContent = "—";
    el.classList.remove("ok", "bad");
  }
  document.getElementById("answers").style.display = "none";
  document.getElementById("clickhint").style.display = "none";
  for (const r of getRanks()) {
    const res = document.getElementById("res_" + r);
    if (res) res.hidden = true;
  }
}
function hintFill(rank) {
  const el = document.getElementById("in_" + rank);
  const lat = (current.answer?.[rank] ?? "").toString().trim();
  if (!lat) return;

  // per-rank cycle: hidden -> lat -> fin -> lat -> ...
  const prev = rankShowMode[rank] || "hidden";
  const next = (prev === "hidden") ? "lat" : (prev === "lat" ? "fin" : "lat");
  rankShowMode[rank] = next;

  el.textContent = formatByMode(rank, next);
  el.classList.add("ok");
}


async function checkAll() {
  const inputs = {};
  for (const r of getRanks()) {
    inputs[r] = document.getElementById("in_" + r).value;
  }

  const res = await fetch("/check", {
    method: "POST",
    credentials: "same-origin",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify({ inputs, quiz_ranks: getRanks() })
  });

  const data = await res.json();
  if (data.error) {
    console.warn("Check error:", data.error);
    return;
  }

  for (const r of getRanks()) {
    const el = document.getElementById("in_" + r);
    const v = (data[r] ? data[r].correct : null);

    el.classList.remove("ok", "bad");
    if (v === true) el.classList.add("ok");
    if (v === false) el.classList.add("bad");
  }
}
function showAnswers() {
  // global cycle: hidden -> lat -> fin -> lat ...
  if (showMode === "hidden") showMode = "lat";
  else showMode = (showMode === "lat") ? "fin" : "lat";

  for (const r of getRanks()) {
    const el = document.getElementById("in_" + r);
    el.textContent = formatByMode(r, showMode);
    el.classList.add("ok");
    rankShowMode[r] = showMode;
  }
  updateShowButton();
}

async function newItem() {
  const res = await fetch("/new", {
    method: "POST",
    credentials: "same-origin"
  });
  const data = await res.json();

  current = data; // now includes answer/meta/mode/given/quiz_ranks
  updateCounter();
  showMode = "hidden";
  rankShowMode = Object.create(null);

  updateMeta(current.meta);
  renderGivenBox();
  buildForm();
  rankShowMode = Object.create(null);
  clearInputs();
  updateShowButton();
}

function updateShowButton() {
  const btn = document.getElementById("showBtn");
  if (!btn) return;

  let next;
  if (showMode === "hidden") next = "lat";
  else if (showMode === "lat") next = "fin";
  else next = "lat";

  btn.textContent = `Näytä ${next}`;
}

function getLatinHint() {
  // Prefer species/genus, fallback to highest available rank
  const order = ["species", "genus", "family", "order", "class", "phylum"];
  for (const r of order) {
    const v = current?.answer?.[r];
    if (v && String(v).trim()) return String(v).trim();
  }
  return "";
}

function visibleRankCount() {
  return (current.quiz_ranks || []).length;
}


function renderGivenBox() {
  const el = document.getElementById("fin");
  if (!el) return;

  const onlyOneRank = visibleRankCount() <= 1;

  // Force Finnish hint if only one rank (e.g. phylum-only cards)
  if (onlyOneRank) {
    el.textContent = current?.meta?.fin ?? "";
    return;
  }

  // Otherwise respect user setting
  if (current.hint_language === "lat") {
    el.textContent = getLatinHint();
  } else {
    el.textContent = current?.meta?.fin ?? "";
  }
}

function formatAnswer(rank) {
  const lat = (current.answer?.[rank] ?? "").toString().trim();
  if (!lat) return "";

  // Finnish name logic:
  // species/genus → use meta.fin
  // higher ranks → meta.fin already matches that node
  const fin = (current.meta?.fin ?? "").toString().trim();

  if (fin && fin.toLowerCase() !== lat.toLowerCase()) {
    return `${lat} (${fin})`;
  }
  return lat;
}

function buildForm() {
  const form = document.getElementById("form");
  const ranks = getRanks();

  form.innerHTML = ranks.map(r => `
    <label class="row" id="row_${r}">
      <span class="rank">${(RANK_FI[r] || r)}</span>

      <div class="cell">
        <span class="staticVal" id="in_${r}">Klikkaa näkyviin</span>
      </div>

      <div class="result" id="res_${r}" hidden></div>
    </label>
  `).join("");

  // bind hint buttons
  for (const r of ranks) {
    document.getElementById("in_" + r).addEventListener("click", () => {
      hintFill(r);
    });
  }

  applyVisibleFieldsFromAnswer(current.answer);
}
    // live checking as you type

    document.getElementById("newBtn").addEventListener("click", () => newItem().catch(console.error));
    document.getElementById("showBtn").addEventListener("click", showAnswers);


    // initial
    updateMeta(current.meta);
    setImage(current.meta);
    renderGivenBox();
    buildForm(); // binds listeners + hides empty fields
    updateShowButton();


    document.addEventListener("keydown", (e) => {
      // don't trigger while typing in an input
      const tag = (e.target?.tagName || "").toLowerCase();
      if (tag === "input" || tag === "textarea") return;

      if (e.key.toLowerCase() === "s") {
        e.preventDefault();
        showAnswers();
      }
    });

  // close lightbox on click outside image
  document.getElementById("lightbox")?.addEventListener("click", () => closeLightbox());
  // close on Escape
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape") closeLightbox();
  });

    document.addEventListener("keydown", (e) => {
      // don't trigger while typing in an input
      const tag = (e.target?.tagName || "").toLowerCase();
      if (tag === "input" || tag === "textarea") return;

      if (e.key.toLowerCase() === "n") {
        e.preventDefault();
        closeLightbox();
        newItem();
      }
    });
  </script>
</body>
</html>
